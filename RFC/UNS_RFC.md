
# **RFC XXXXX — The Universal Number Set (UNS) Specification**
### *Category: Standards Track — Numerical Foundations, Computation Models*
### *Status: Draft*
### *Author: Reed Kimble*
### *Created: 2025-11-27*

---

## **Abstract**

This document specifies the **Universal Number Set (UNS)**, a representation-invariant numerical framework in which a number is defined as a normalized microstate-distributed function. The specification defines:

- The UNS universe and microstate domain  
- The definition of UNS values  
- The definition of states  
- The readout mechanism  
- Dimensional transforms  
- Lifted operations  
- Novel values (closure over undefined classical operations)  
- Type system  
- Grammar  
- Execution model (UNS\_Runtime32)  
- Conformance and interoperability rules  
- Security considerations  

This document is intended as the authoritative standard for interoperable UNS-compatible implementations.

---

# **Table of Contents**

1. Introduction  
2. Terminology  
3. Theoretical Foundation  
4. UNS Universe  
5. UNS Values  
6. States  
7. Readout  
8. Dimensional Transform  
9. Lifted Operations  
10. Novel Values  
11. Type System  
12. Syntax and Grammar  
13. Execution Model (UNS\_Runtime32\_Spec)  
14. Conformance Requirements  
15. Security Considerations  
16. IANA Considerations  
17. References  
18. UNS Expression Files (.unse)  
Appendix A — Rationale  
Appendix B — Example Expressions  

---

# **1. Introduction**

The Universal Number Set (UNS) defines a generalized numeric system in which a number is a function over a normalized microstate domain.  
UNS provides:

- Classical arithmetic as a subset  
- Microstate-distributed values  
- Dimension-invariant evaluation  
- Fully total operations (including undefined classical cases)  
- A canonical execution model suitable for microcontrollers, web runtimes, or desktop environments  

This RFC defines the standard so that independent implementations can interoperate cleanly.

---

# **2. Terminology**

- **UValue** — A UNS number; a function from microstates to complex values.  
- **UState** — A normalized weighting function used for evaluation.  
- **Microstate** — A discrete index representing a domain element in the runtime.  
- **Readout** — Extraction of a classical scalar from a UNS value via a state.  
- **Lifted Operation** — A scalar operation promoted to operate over microstates.  
- **Novel Value** — A first-class UNS value generated by undefined classical operations.  
- **Runtime32** — The canonical implementation model (signed 32-bit integers, Q16.16 fixed point).  

---

# **3. Theoretical Foundation**

UNS generalizes classical numbers by embedding them as constant functions:

```
a ↦ f(x) = a
```

A UNS value may vary across microstates:

```
f(x0), f(x1), …, f(xN)
```

Readout extracts a classical scalar by integrating over a state:

```
read(f | ψ)
```

UNS requires dimensional invariance:

```
read(f | D(N, ψ)) = read(f | ψ)
```

---

# **4. UNS Universe**

A UNS universe is defined as a measure space:

```
U = (X, μ)
```

Requirement:

```
μ(X) = 1
```

---

# **5. UNS Values**

A UNS value is a function:

```
f : X -> ℂ
```

Classical scalars embed as constant UNS values.

---

# **6. States**

A state ψ is defined as:

```
ψ : X -> ℂ
```

Normalization constraint:

```
∫X |ψ|^2 dμ = 1
```

---

# **7. Readout**

The readout operator is:

```
read(f | ψ) =
    ∫X f(x) * |ψ(x)|^2 dμ(x)
```

---

# **8. Dimensional Transform**

D(N, ψ) restructures ψ across N dimensions while preserving normalization and interpretive identity.

Requirement:

```
read(f | ψ) == read(f | D(N, ψ))
```

---

# **9. Lifted Operations**


*This section will be completed in a future revision.*


UNS supports lifted unary and binary scalar functions.

### Unary:
```
lift1(h, f)(x) = h(f(x))
```

### Binary:
```
lift2(k, f, g)(x) = k(f(x), g(x))
```

If `k` is undefined for a given pair, the value becomes a **novel** value.

---

# **10. Novel Values**

If a lifted operation encounters undefined classical behavior:

```
divide(a, 0)
```

UNS produces:

```
novel(divide, (a,0), index=x_i)
```

Novel values are first-class and must be traceable.

---

# **11. Type System**

UNS supports:

- `scalar`  
- `uvalue`  
- `ustate`  
- `novel`  

With partiality annotations for lifted operations.

---

# **12. Syntax and Grammar (Updated)**

This section defines the lexical rules and abstract grammar for UNS source text.

## **12.1 Character Encoding**

- UNS source text **MUST** be encoded as UTF-8.  
- Implementations **MUST** accept both LF and CRLF line endings.

## **12.2 Tokens**

UNS source is tokenized into the following classes:

- **Keywords**: `let`, `state`, `const`, `read`, `lift1`, `lift2`, `D`, `true`, `false`.  
- **Operators**: `+u`, `*u`, `*s`, `=`, `|`, `,`, `(`, `)`.  
- **Identifiers**: must match the regex `[A-Za-z_][A-Za-z0-9_]*` and **MUST NOT** collide with keywords.  
- **Numeric literals**:  
    - integer: `[0-9]+`  
    - float: `[0-9]+\.[0-9]+`  
    - complex (optional): `<real>(+|-)<imag>i` (e.g., `3+4i`, `2.5-0.75i`)  
- **Whitespace**: spaces, tabs, and newlines (ignored except as separators).  
- **Comments**: see Section 12.3.

## **12.3 Comments**

- UNS uses C-style single-line comments only.  
- A comment begins with `//` and continues to the end of the line.  
- Comments may appear on their own line or after code on the same line.  
- The `#` character has **no special meaning** in UNS and **MUST NOT** be treated as a comment delimiter.

Example:

```text
// This is a comment
let a = const(3)  // Inline comment is also allowed
```

## **12.4 Abstract Grammar**

The abstract grammar for UNS expressions is:

```ebnf
program   ::= item* ;

item      ::= letdecl
                        | statedecl
                        | expr ;

letdecl   ::= "let" IDENT "=" expr ;

statedecl ::= "state" IDENT "=" expr ;

expr      ::= const-expr
                        | ref-expr
                        | binary-expr
                        | lift1-expr
                        | lift2-expr
                        | read-expr
                        | d-expr
                        | "(" expr ")" ;

const-expr ::= "const" "(" NUMBER ")" ;

ref-expr   ::= IDENT ;

binary-expr ::= expr OP expr ;

lift1-expr ::= "lift1" "(" IDENT "," expr ")" ;

lift2-expr ::= "lift2" "(" IDENT "," expr "," expr ")" ;

read-expr  ::= "read" "(" expr "|" expr ")" ;

d-expr     ::= "D" "(" NUMBER "," expr ")" ;

OP         ::= "+u" | "*u" | "*s" ;
```

A conforming parser **MUST** accept this grammar. Implementations **MAY** extend it with additional built-ins, provided all standard UNS constructs remain valid and unambiguous.

---

# **13. UNS_Runtime32 Specification**

### 13.1 Primitive Type
```
Word32 = signed 32-bit integer (-2^31..2^31-1)
```

### 13.2 Complex Fixed-Point
Q16.16:

- upper 16 bits = integer  
- lower 16 bits = fractional  

### 13.3 Value Representation

```
UValue32 = array[M] of Complex32 or NovelRef
UState32 = array[M] of Complex32
```

### 13.4 Novel Table
Stores provenance entries.

### 13.5 Readout (discrete)
```
sum = Σ f[i] * |ψ[i]|^2
```

### 13.6 Lifted Ops
Elementwise over microstates.

---

# **14. Conformance Requirements**

A conforming UNS implementation MUST:

- Support classical embedding  
- Implement readout semantics  
- Support lifted total operations  
- Maintain novel value provenance  
- Preserve dimensional invariance  
- Implement Runtime32 or a compatible superset  

---

# **15. Security Considerations**

UNS contains no cryptographic features and presents no inherent security risks.  
Implementations must guard against:

- Overflow  
- Malformed novel values  
- Unbounded recursion in lifted operations  

---

# **16. IANA Considerations**

None.

---

# **17. References**

1. Shapiro, S. *Philosophy of Mathematics*. OUP, 1997.  
2. Landry, E. *Categories for the Working Philosopher*. OUP, 2007.  

---
# **20. UNS Expression Files (.unse)**

This section standardizes the canonical source file format for UNS programs.

## **20.1 File Extension**

- The file extension **MUST** be `.unse`.  
- Tools **MUST** treat `.unse` files as UNS source files.  
- Tooling **MAY** provide syntax highlighting, linting, or execution support for `.unse`.  
- Other extensions **MUST NOT** be assumed to contain valid UNS unless explicitly configured.

## **20.2 Encoding and Line Endings**

A `.unse` file:

- **MUST** be UTF-8 encoded.  
- **MAY** begin with a UTF-8 BOM; implementations should tolerate but not require it.  
- **MUST** accept either LF (`\n`) or CRLF (`\r\n`).  
- Implementations **SHOULD** preserve original line endings when practical.

## **20.3 Logical Content Model**

The content of a `.unse` file is a single UNS program that follows the grammar in Section 12:

```ebnf
program ::= item* ;
```

Valid items are:

- `let` declarations.  
- `state` declarations.  
- Top-level expressions.

Constraints:

- A `.unse` file **MUST** be lexically valid under Section 12.  
- A `.unse` file **SHOULD** be syntactically valid.  
- Tools **MAY** accept drafts that are incomplete but **MUST NOT** treat them as executable programs.  
- A `.unse` file **MAY** be empty; an empty file represents an empty program.

## **20.4 Comments and Documentation**

- Comments **MUST** use `//` as described in Section 12.3.  
- Documentation or examples inside `.unse` files should use comments rather than external markup.

Example:

```text
// Hypotenuse example in UNS
let A = const(3)
let B = const(4)
let S = (A *u A) +u (B *u B)
let H = lift1(sqrt, S)

// A simple uniform state
state psi = const(1.0)

// Readout gives the classical hypotenuse = 5
read(H | psi)
```

## **20.5 File-Level Metadata**

This RFC does not mandate metadata headers for `.unse` files. Implementations **MAY** adopt conventions (e.g., leading `// module: primes`), but such metadata is out of scope. Tools **MUST** ignore unknown metadata-style comments.

## **20.6 Multi-File and Module Behavior**

Each `.unse` file is treated as a self-contained compilation unit. Import, module, or package semantics are intentionally unspecified. Implementations **MAY** introduce higher-level project semantics provided:

- The meaning of individual `.unse` files as standalone UNS programs is preserved.  
- `.unse` files remain valid independently per this specification.

---

# **Appendix A — Rationale**

UNS seeks to resolve limitations of classical numeric systems by introducing:

- distribution-sensitive numbers,  
- dimension-invariant semantics,  
- a default-total arithmetic,  
- and canonical execution semantics.

---

# **Appendix B — Example Expressions**

```
let A = const(3)
let B = const(4)
let S = (A *u A) +u (B *u B)
let H = lift1(sqrt, S)
state psi = const(1.0)
read(H | psi)
```

---

*End of RFC XXXXX*
